# 撤销/重做功能详细设计方案

## 📋 目录

1. [系统架构设计](#系统架构设计)
2. [保存前的撤销/重做机制](#保存前的撤销重做机制)
3. [保存后的撤销/重做机制](#保存后的撤销重做机制)
4. [多次撤销和多次重做](#多次撤销和多次重做)
5. [交替撤销和重做操作](#交替撤销和重做操作)
6. [可撤销/重做的操作列表](#可撤销重做的操作列表)
7. [边界情况和异常处理](#边界情况和异常处理)
8. [性能优化策略](#性能优化策略)

---

## 系统架构设计

### 1.1 核心数据结构

系统维护三个核心数据结构来支持撤销/重做功能：

```
┌─────────────────────────────────────────────────────────┐
│                    撤销/重做系统架构                      │
├─────────────────────────────────────────────────────────┤
│                                                           │
│  ┌──────────────┐      ┌──────────────┐      ┌─────────┐│
│  │  撤销栈      │      │  待保存变更  │      │  场景   ││
│  │ (UndoStack) │◄────►│  列表        │◄────►│ (Scene) ││
│  │              │      │ (Pending)    │      │         ││
│  └──────────────┘      └──────────────┘      └─────────┘│
│         │                      │                  │      │
│         └──────────────────────┴──────────────────┘      │
│                           │                               │
│                    ┌──────▼──────┐                       │
│                    │   数据库     │                       │
│                    │  (Database)  │                       │
│                    └─────────────┘                       │
└─────────────────────────────────────────────────────────┘
```

#### 1.1.1 撤销栈 (QUndoStack)

**作用**：记录所有可撤销的操作历史

**特性**：
- 使用 Qt 的 `QUndoStack` 实现
- 支持最多 **50 步**撤销（可配置）
- 维护一个线性历史记录
- 支持撤销和重做操作

**状态表示**：
```
撤销栈状态：
[命令1] [命令2] [命令3] ... [命令N] | [当前指针位置]
                                    ↑
                              可以撤销到这里
```

#### 1.1.2 待保存变更列表 (m_pendingChanges)

**作用**：跟踪需要保存到数据库的变更

**数据结构**：
```cpp
enum ChangeType {
    ChangeAdded,      // 新增实体
    ChangeModified,   // 修改实体属性
    ChangeDeleted     // 删除实体
};

struct PendingChange {
    ChangeType type;              // 变更类型
    QString entityType;          // "pipeline" 或 "facility"
    QVariant data;               // Pipeline 或 Facility 对象
    int originalId;              // 原始数据库ID（用于修改和删除）
    QGraphicsItem *graphicsItem; // 关联的图形项
    QDateTime timestamp;         // 变更时间戳（可选）
};
```

#### 1.1.3 场景状态 (QGraphicsScene)

**作用**：当前地图上显示的图形项集合

**特性**：
- 实时反映用户看到的地图状态
- 与撤销栈和待保存列表保持同步
- 包含所有可见的管线和设施

---

## 保存前的撤销/重做机制

### 2.1 保存前的操作流程

#### 2.1.1 新增实体（未保存）

**操作序列**：
```
1. 用户绘制新管线A
   ├─ 撤销栈：添加 AddEntityCommand(A)
   ├─ 待保存列表：添加 ChangeAdded(A)
   └─ 场景：显示管线A

2. 用户绘制新管线B
   ├─ 撤销栈：添加 AddEntityCommand(B)
   ├─ 待保存列表：添加 ChangeAdded(B)
   └─ 场景：显示管线A和B

3. 用户撤销（Ctrl+Z）
   ├─ 撤销栈：撤销 AddEntityCommand(B)
   ├─ 待保存列表：移除 ChangeAdded(B)
   └─ 场景：只显示管线A

4. 用户再次撤销（Ctrl+Z）
   ├─ 撤销栈：撤销 AddEntityCommand(A)
   ├─ 待保存列表：移除 ChangeAdded(A)
   └─ 场景：空场景

5. 用户重做（Ctrl+Y）
   ├─ 撤销栈：重做 AddEntityCommand(A)
   ├─ 待保存列表：添加 ChangeAdded(A)
   └─ 场景：显示管线A

6. 用户重做（Ctrl+Y）
   ├─ 撤销栈：重做 AddEntityCommand(B)
   ├─ 待保存列表：添加 ChangeAdded(B)
   └─ 场景：显示管线A和B
```

**关键点**：
- 未保存的实体撤销时，从待保存列表中移除
- 未保存的实体重做时，重新添加到待保存列表
- 场景状态与待保存列表始终保持一致

#### 2.1.2 删除已保存实体（未保存删除操作）

**操作序列**：
```
1. 场景中有已保存的管线C（数据库ID > 0）

2. 用户删除管线C
   ├─ 撤销栈：添加 DeleteEntityCommand(C)
   ├─ 待保存列表：添加 ChangeDeleted(C)
   └─ 场景：C从地图消失

3. 用户撤销删除（Ctrl+Z）
   ├─ 撤销栈：撤销 DeleteEntityCommand(C)
   ├─ 待保存列表：移除 ChangeDeleted(C)
   └─ 场景：C重新显示

4. 用户重做删除（Ctrl+Y）
   ├─ 撤销栈：重做 DeleteEntityCommand(C)
   ├─ 待保存列表：重新添加 ChangeDeleted(C)
   └─ 场景：C再次消失
```

**关键点**：
- 删除已保存实体时，创建 ChangeDeleted 记录
- 撤销删除时，移除 ChangeDeleted 记录
- 重做删除时，重新添加 ChangeDeleted 记录

#### 2.1.3 修改实体属性（未保存）

**操作序列**：
```
1. 场景中有已保存的管线D（名称="旧名称"）

2. 用户修改管线D的名称
   ├─ 撤销栈：添加 ChangePropertyCommand(D, "名称", "旧名称", "新名称")
   ├─ 待保存列表：添加 ChangeModified(D)
   └─ 场景：显示新名称

3. 用户撤销修改（Ctrl+Z）
   ├─ 撤销栈：撤销 ChangePropertyCommand
   ├─ 待保存列表：移除 ChangeModified(D)（如果修改被完全撤销）
   └─ 场景：显示旧名称

4. 用户重做修改（Ctrl+Y）
   ├─ 撤销栈：重做 ChangePropertyCommand
   ├─ 待保存列表：重新添加 ChangeModified(D)
   └─ 场景：显示新名称
```

**关键点**：
- 属性修改需要比较旧值和新值
- 如果修改被撤销到原始值，从待保存列表移除
- 如果修改被重做，重新添加到待保存列表

---

## 保存后的撤销/重做机制

### 3.1 保存操作的影响

#### 3.1.1 保存操作流程

```
保存操作 (onSaveAll):
1. 遍历 m_pendingChanges
2. 对每个变更执行数据库操作：
   - ChangeAdded → INSERT
   - ChangeModified → UPDATE
   - ChangeDeleted → DELETE
3. 清空 m_pendingChanges
4. ⚠️ 重要：不清空撤销栈 (m_undoStack)
```

**关键设计决策**：
- **撤销栈在保存后不清空**：允许用户撤销保存前的操作
- **待保存列表在保存后清空**：所有变更已同步到数据库
- **场景状态保持不变**：用户看到的地图不变

### 3.2 保存后的撤销场景

#### 3.2.1 撤销保存前的新增操作

**操作序列**：
```
1. 用户绘制管线E（未保存）
   ├─ 撤销栈：AddEntityCommand(E)
   └─ 待保存列表：ChangeAdded(E)

2. 用户保存
   ├─ 数据库：INSERT E（获得ID=100）
   ├─ 撤销栈：保持不变
   └─ 待保存列表：清空

3. 用户撤销（Ctrl+Z）
   ├─ 撤销栈：撤销 AddEntityCommand(E)
   ├─ 待保存列表：添加 ChangeDeleted(E, ID=100)
   └─ 场景：E从地图消失

4. 用户再次保存
   ├─ 数据库：DELETE E (WHERE id=100)
   └─ 待保存列表：清空
```

**关键点**：
- 保存后撤销新增操作，会创建 ChangeDeleted 记录
- 下次保存时，会从数据库删除该实体
- 实体在数据库中的ID被保留，用于删除操作

#### 3.2.2 撤销保存前的删除操作

**操作序列**：
```
1. 场景中有已保存的管线F（ID=200）

2. 用户删除管线F
   ├─ 撤销栈：DeleteEntityCommand(F)
   └─ 待保存列表：ChangeDeleted(F, ID=200)

3. 用户保存
   ├─ 数据库：DELETE F (WHERE id=200)
   ├─ 撤销栈：保持不变
   └─ 待保存列表：清空

4. 用户撤销（Ctrl+Z）
   ├─ 撤销栈：撤销 DeleteEntityCommand(F)
   ├─ 待保存列表：添加 ChangeAdded(F, ID=200)
   └─ 场景：F重新显示

5. 用户再次保存
   ├─ 数据库：INSERT F（使用原ID=200，如果支持）
   └─ 待保存列表：清空
```

**关键点**：
- 保存后撤销删除操作，会创建 ChangeAdded 记录
- 需要恢复实体的完整数据（从撤销栈中获取）
- 可能需要处理ID冲突（如果数据库不支持恢复原ID）

#### 3.2.3 撤销保存前的修改操作

**操作序列**：
```
1. 场景中有已保存的管线G（名称="原始名称", ID=300）

2. 用户修改管线G的名称
   ├─ 撤销栈：ChangePropertyCommand(G, "名称", "原始名称", "新名称")
   └─ 待保存列表：ChangeModified(G, ID=300)

3. 用户保存
   ├─ 数据库：UPDATE G SET name="新名称" WHERE id=300
   ├─ 撤销栈：保持不变
   └─ 待保存列表：清空

4. 用户撤销（Ctrl+Z）
   ├─ 撤销栈：撤销 ChangePropertyCommand
   ├─ 待保存列表：添加 ChangeModified(G, "名称", "新名称", "原始名称")
   └─ 场景：显示"原始名称"

5. 用户再次保存
   ├─ 数据库：UPDATE G SET name="原始名称" WHERE id=300
   └─ 待保存列表：清空
```

**关键点**：
- 保存后撤销修改操作，会创建反向的 ChangeModified 记录
- 需要保存旧值和新值，以便恢复

---

## 多次撤销和多次重做

### 4.1 多次撤销机制

#### 4.1.1 撤销栈状态变化

```
初始状态：
[命令1] [命令2] [命令3] [命令4] [命令5] | 指针位置：5

撤销1次（Ctrl+Z）：
[命令1] [命令2] [命令3] [命令4] | [命令5] 指针位置：4

撤销2次（Ctrl+Z）：
[命令1] [命令2] [命令3] | [命令4] [命令5] 指针位置：3

撤销3次（Ctrl+Z）：
[命令1] [命令2] | [命令3] [命令4] [命令5] 指针位置：2
```

#### 4.1.2 多次撤销示例

**场景**：用户进行了5个操作，然后连续撤销3次

```
操作历史：
1. 绘制管线A → AddEntityCommand(A)
2. 绘制管线B → AddEntityCommand(B)
3. 删除管线C → DeleteEntityCommand(C)
4. 修改管线D → ChangePropertyCommand(D)
5. 移动设施E → MoveEntityCommand(E)

撤销栈状态：
[Add(A)] [Add(B)] [Del(C)] [Chg(D)] [Mov(E)] | 指针：5

执行撤销1（Ctrl+Z）：
- 撤销栈：撤销 MoveEntityCommand(E)
- 场景：E回到原位置
- 待保存列表：更新（如果E有相关变更）
- 指针位置：4

执行撤销2（Ctrl+Z）：
- 撤销栈：撤销 ChangePropertyCommand(D)
- 场景：D恢复旧属性
- 待保存列表：更新
- 指针位置：3

执行撤销3（Ctrl+Z）：
- 撤销栈：撤销 DeleteEntityCommand(C)
- 场景：C重新显示
- 待保存列表：移除 ChangeDeleted(C)
- 指针位置：2
```

#### 4.1.3 撤销限制

**撤销步数限制**：
- 默认最多支持 **50 步**撤销
- 超过50步的操作无法撤销
- 可以通过 `setUndoLimit()` 配置

**撤销边界**：
- 撤销到撤销栈底部时，无法继续撤销
- 撤销按钮会变为禁用状态
- 场景恢复到初始加载状态（或上次保存后的状态）

### 4.2 多次重做机制

#### 4.2.1 重做栈状态变化

```
撤销3次后的状态：
[命令1] [命令2] | [命令3] [命令4] [命令5] 指针位置：2

重做1次（Ctrl+Y）：
[命令1] [命令2] [命令3] | [命令4] [命令5] 指针位置：3

重做2次（Ctrl+Y）：
[命令1] [命令2] [命令3] [命令4] | [命令5] 指针位置：4

重做3次（Ctrl+Y）：
[命令1] [命令2] [命令3] [命令4] [命令5] | 指针位置：5
```

#### 4.2.2 多次重做示例

**场景**：在撤销3次后，连续重做3次

```
当前状态（已撤销3次）：
撤销栈：[Add(A)] [Add(B)] | [Del(C)] [Chg(D)] [Mov(E)] 指针：2
场景：显示A和B，C、D、E处于撤销状态

执行重做1（Ctrl+Y）：
- 撤销栈：重做 DeleteEntityCommand(C)
- 场景：C从地图消失
- 待保存列表：添加 ChangeDeleted(C)
- 指针位置：3

执行重做2（Ctrl+Y）：
- 撤销栈：重做 ChangePropertyCommand(D)
- 场景：D应用新属性
- 待保存列表：添加 ChangeModified(D)
- 指针位置：4

执行重做3（Ctrl+Y）：
- 撤销栈：重做 MoveEntityCommand(E)
- 场景：E移动到新位置
- 待保存列表：更新（如果E有相关变更）
- 指针位置：5
```

#### 4.2.3 重做限制

**重做边界**：
- 重做到撤销栈顶部时，无法继续重做
- 重做按钮会变为禁用状态
- 场景恢复到最新状态

**新操作影响**：
- 如果在撤销状态下执行新操作，会清除重做栈
- 例如：撤销3次后，如果用户绘制新实体，重做栈被清空

---

## 交替撤销和重做操作

### 5.1 交替操作的基本原理

#### 5.1.1 撤销栈的分叉处理

```
初始状态：
[命令1] [命令2] [命令3] [命令4] | 指针：4

撤销2次：
[命令1] [命令2] | [命令3] [命令4] 指针：2

执行新操作（绘制新实体）：
[命令1] [命令2] [命令5] | 指针：3
注意：[命令3] [命令4] 被清除，无法重做
```

**关键规则**：
- 在撤销状态下执行新操作，会清除所有可重做的命令
- 这是标准的撤销/重做行为，与大多数软件一致

### 5.2 交替操作示例

#### 5.2.1 示例1：撤销→重做→撤销→重做

```
初始状态：
[Add(A)] [Add(B)] [Add(C)] | 指针：3

1. 撤销（Ctrl+Z）
   [Add(A)] [Add(B)] | [Add(C)] 指针：2
   场景：只显示A和B

2. 重做（Ctrl+Y）
   [Add(A)] [Add(B)] [Add(C)] | 指针：3
   场景：显示A、B和C

3. 撤销（Ctrl+Z）
   [Add(A)] [Add(B)] | [Add(C)] 指针：2
   场景：只显示A和B

4. 重做（Ctrl+Y）
   [Add(A)] [Add(B)] [Add(C)] | 指针：3
   场景：显示A、B和C
```

#### 5.2.2 示例2：撤销→新操作→撤销

```
初始状态：
[Add(A)] [Add(B)] [Add(C)] | 指针：3

1. 撤销（Ctrl+Z）
   [Add(A)] [Add(B)] | [Add(C)] 指针：2
   场景：只显示A和B

2. 绘制新实体D
   [Add(A)] [Add(B)] [Add(D)] | 指针：3
   注意：[Add(C)] 被清除，无法重做
   场景：显示A、B和D

3. 撤销（Ctrl+Z）
   [Add(A)] [Add(B)] | [Add(D)] 指针：2
   场景：只显示A和B
```

#### 5.2.3 示例3：复杂交替操作

```
操作序列：
1. 绘制A → [Add(A)] | 指针：1
2. 绘制B → [Add(A)] [Add(B)] | 指针：2
3. 删除C → [Add(A)] [Add(B)] [Del(C)] | 指针：3
4. 修改D → [Add(A)] [Add(B)] [Del(C)] [Chg(D)] | 指针：4

5. 撤销2次（Ctrl+Z × 2）
   [Add(A)] [Add(B)] | [Del(C)] [Chg(D)] 指针：2
   场景：显示A和B，C和D处于撤销状态

6. 重做1次（Ctrl+Y）
   [Add(A)] [Add(B)] [Del(C)] | [Chg(D)] 指针：3
   场景：显示A和B，C被删除

7. 撤销1次（Ctrl+Z）
   [Add(A)] [Add(B)] | [Del(C)] [Chg(D)] 指针：2
   场景：显示A和B，C重新显示

8. 绘制新实体E
   [Add(A)] [Add(B)] [Add(E)] | 指针：3
   注意：[Del(C)] [Chg(D)] 被清除
   场景：显示A、B和E

9. 撤销1次（Ctrl+Z）
   [Add(A)] [Add(B)] | [Add(E)] 指针：2
   场景：只显示A和B
```

### 5.3 交替操作中的待保存列表同步

#### 5.3.1 同步规则

每次撤销/重做操作后，都需要同步更新待保存列表：

```
撤销操作后：
1. 执行撤销栈的 undo()
2. 调用 handleUndoForPendingChanges()
   - 检查场景中的图形项
   - 更新待保存列表
   - 处理已保存和未保存的实体

重做操作后：
1. 执行撤销栈的 redo()
2. 调用 handleRedoForPendingChanges()
   - 检查场景中的图形项
   - 更新待保存列表
   - 处理已保存和未保存的实体
```

#### 5.3.2 同步示例

```
场景：撤销已保存实体的删除操作

初始状态：
- 场景：显示管线F（ID=100，已保存）
- 撤销栈：[Del(F)] | 指针：1
- 待保存列表：[ChangeDeleted(F, ID=100)]

执行撤销（Ctrl+Z）：
1. 撤销栈：撤销 DeleteEntityCommand(F)
2. 场景：F重新显示
3. handleUndoForPendingChanges()：
   - 检测到F在场景中
   - 检测到待保存列表中有 ChangeDeleted(F)
   - 从待保存列表移除 ChangeDeleted(F)
4. 结果：
   - 撤销栈：[Del(F)] | 指针：0
   - 待保存列表：[]（空）
   - 场景：显示F

执行重做（Ctrl+Y）：
1. 撤销栈：重做 DeleteEntityCommand(F)
2. 场景：F从地图消失
3. handleRedoForPendingChanges()：
   - 检测到F不在场景中
   - 检测到F有数据库ID（ID=100）
   - 添加 ChangeDeleted(F, ID=100) 到待保存列表
4. 结果：
   - 撤销栈：[Del(F)] | 指针：1
   - 待保存列表：[ChangeDeleted(F, ID=100)]
   - 场景：F消失
```

---

## 可撤销/重做的操作列表

### 6.1 完全支持的操作

#### 6.1.1 绘制操作

| 操作 | 命令类 | 撤销支持 | 重做支持 | 说明 |
|------|--------|---------|---------|------|
| 绘制管线 | `AddEntityCommand` | ✅ | ✅ | 绘制完成后可撤销 |
| 绘制设施 | `AddEntityCommand` | ✅ | ✅ | 绘制完成后可撤销 |

**实现细节**：
- 绘制完成后立即创建命令并推入撤销栈
- 撤销时从场景移除图形项
- 重做时重新添加到场景

#### 6.1.2 删除操作

| 操作 | 命令类 | 撤销支持 | 重做支持 | 说明 |
|------|--------|---------|---------|------|
| 删除实体 | `DeleteEntityCommand` | ✅ | ✅ | 删除后可撤销恢复 |

**实现细节**：
- 删除时保存实体数据（用于恢复）
- 撤销时重新添加到场景
- 重做时再次从场景移除

#### 6.1.3 修改操作

| 操作 | 命令类 | 撤销支持 | 重做支持 | 说明 |
|------|--------|---------|---------|------|
| 修改属性 | `ChangePropertyCommand` | ✅ | ✅ | 属性修改后可撤销 |
| 粘贴样式 | `ChangeStyleCommand` | ✅ | ✅ | 样式修改后可撤销 |
| 移动实体 | `MoveEntityCommand` | ✅ | ✅ | 仅设施支持移动 |

**实现细节**：
- 修改时保存旧值和新值
- 撤销时恢复旧值
- 重做时应用新值
- 移动命令支持合并连续移动

### 6.2 不支持撤销/重做的操作

#### 6.2.1 视图操作

| 操作 | 说明 | 不支持原因 |
|------|------|-----------|
| 地图缩放 | 缩放地图视图 | 视图操作，不影响数据 |
| 地图平移 | 平移地图视图 | 视图操作，不影响数据 |
| 图层显示/隐藏 | 切换图层可见性 | 视图操作，不影响数据 |

#### 6.2.2 查询和分析操作

| 操作 | 说明 | 不支持原因 |
|------|------|-----------|
| 空间查询 | 查询实体 | 只读操作，不修改数据 |
| 连通性分析 | 分析管网连通性 | 只读操作，不修改数据 |
| 爆管分析 | 分析爆管影响 | 只读操作，不修改数据 |
| 健康度评估 | 评估资产健康度 | 只读操作，不修改数据 |

#### 6.2.3 系统操作

| 操作 | 说明 | 不支持原因 |
|------|------|-----------|
| 保存 | 保存到数据库 | 系统操作，不应撤销 |
| 刷新数据 | 重新加载数据 | 会清空撤销栈 |
| 打开项目 | 加载项目文件 | 会清空撤销栈 |
| 新建项目 | 创建新项目 | 会清空撤销栈 |

### 6.3 操作分类总结

```
可撤销操作（影响数据）：
├── 绘制操作
│   ├── 绘制管线 ✅
│   └── 绘制设施 ✅
├── 删除操作
│   └── 删除实体 ✅
└── 修改操作
    ├── 修改属性 ✅
    ├── 粘贴样式 ✅
    └── 移动实体 ✅

不可撤销操作（不影响数据或系统操作）：
├── 视图操作
│   ├── 地图缩放 ❌
│   ├── 地图平移 ❌
│   └── 图层控制 ❌
├── 查询操作
│   ├── 空间查询 ❌
│   ├── 连通性分析 ❌
│   ├── 爆管分析 ❌
│   └── 健康度评估 ❌
└── 系统操作
    ├── 保存 ❌
    ├── 刷新 ❌
    ├── 打开项目 ❌
    └── 新建项目 ❌
```

---

## 边界情况和异常处理

### 7.1 撤销栈边界

#### 7.1.1 撤销到栈底

**场景**：用户连续撤销，直到撤销栈为空

```
处理方式：
1. 检查撤销栈是否为空
2. 如果为空，禁用撤销按钮
3. 显示提示："已撤销到初始状态"
4. 场景恢复到初始加载状态
```

#### 7.1.2 重做到栈顶

**场景**：用户连续重做，直到重做到最新状态

```
处理方式：
1. 检查是否还有可重做的命令
2. 如果没有，禁用重做按钮
3. 显示提示："已重做到最新状态"
4. 场景恢复到最新状态
```

### 7.2 撤销栈溢出

#### 7.2.1 超过撤销步数限制

**场景**：用户执行了超过50步操作

```
处理方式：
1. 撤销栈自动移除最旧的操作
2. 保持最多50步可撤销
3. 显示提示："撤销历史已满，最旧的操作将被移除"
4. 最旧的操作无法撤销
```

### 7.3 数据一致性

#### 7.3.1 实体被外部删除

**场景**：撤销栈中引用的实体已被外部删除（如数据库删除）

```
处理方式：
1. 检测实体是否存在
2. 如果不存在，跳过该命令
3. 记录警告日志
4. 继续处理下一个命令
```

#### 7.3.2 图形项丢失

**场景**：撤销栈中引用的图形项指针失效

```
处理方式：
1. 检查图形项指针有效性
2. 如果无效，通过实体ID重新查找
3. 如果找不到，跳过该命令
4. 记录错误日志
```

### 7.4 保存冲突

#### 7.4.1 撤销已保存的实体后再次保存

**场景**：用户撤销了已保存的实体，然后保存

```
处理方式：
1. 检测待保存列表中的 ChangeDeleted 记录
2. 执行数据库删除操作
3. 如果删除失败（实体已被删除），记录警告
4. 继续处理其他变更
```

#### 7.4.2 并发修改冲突

**场景**：多个用户同时修改同一实体

```
处理方式：
1. 保存时检查实体版本号（如果支持）
2. 如果版本不匹配，提示用户
3. 提供合并选项或覆盖选项
4. 记录冲突日志
```

### 7.5 内存管理

#### 7.5.1 撤销栈内存占用

**场景**：撤销栈占用过多内存

```
处理方式：
1. 限制撤销栈大小（默认50步）
2. 定期清理过期的命令
3. 使用对象池复用命令对象（可选优化）
4. 监控内存使用情况
```

---

## 性能优化策略

### 8.1 命令合并

#### 8.1.1 移动命令合并

**场景**：用户连续移动同一实体

```
优化策略：
1. MoveEntityCommand 实现 mergeWith() 方法
2. 检测连续的移动操作
3. 合并为单个命令
4. 减少撤销栈大小

示例：
原始： [Mov(A, p1→p2)] [Mov(A, p2→p3)] [Mov(A, p3→p4)]
合并后： [Mov(A, p1→p4)]
```

#### 8.1.2 属性修改合并

**场景**：用户连续修改同一属性

```
优化策略：
1. ChangePropertyCommand 实现 mergeWith() 方法
2. 检测相同属性的连续修改
3. 合并为单个命令（只保留第一次的旧值和最后一次的新值）

示例：
原始： [Chg(A, "名称", "旧", "中")] [Chg(A, "名称", "中", "新")]
合并后： [Chg(A, "名称", "旧", "新")]
```

### 8.2 延迟更新

#### 8.2.1 待保存列表延迟更新

**场景**：快速连续撤销/重做

```
优化策略：
1. 使用定时器延迟更新待保存列表
2. 在用户停止操作一段时间后（如500ms）再更新
3. 减少不必要的列表遍历和更新

实现：
- 撤销/重做时，标记需要更新
- 启动定时器（500ms）
- 定时器触发时，执行更新
- 如果定时器未触发又有新操作，重置定时器
```

### 8.3 批量操作

#### 8.3.1 批量撤销/重做

**场景**：用户需要撤销多个操作

```
优化策略：
1. 支持批量撤销（如撤销到某个标记点）
2. 使用宏命令（MacroCommand）组合多个命令
3. 一次性执行多个撤销/重做操作

实现：
- 创建 UndoMacroCommand 类
- 将多个命令组合为一个宏命令
- 一次性撤销/重做整个宏命令
```

### 8.4 数据快照

#### 8.4.1 定期创建快照

**场景**：撤销栈过大，恢复速度慢

```
优化策略：
1. 定期创建场景快照（如每10步）
2. 撤销时，如果距离快照较近，从快照恢复
3. 减少逐个命令撤销的开销

实现：
- 每N步操作后创建快照
- 快照包含场景状态和待保存列表
- 撤销时，检查最近的快照
- 从快照恢复，然后执行剩余的撤销操作
```

---

## 实现检查清单

### 9.1 核心功能

- [x] 撤销栈初始化（QUndoStack，50步限制）
- [x] 待保存列表管理（m_pendingChanges）
- [x] 撤销操作处理（handleUndoButtonClicked）
- [x] 重做操作处理（handleRedoButtonClicked）
- [x] 撤销后待保存列表同步（handleUndoForPendingChanges）
- [x] 重做后待保存列表同步（handleRedoForPendingChanges）

### 9.2 命令类实现

- [x] AddEntityCommand（添加实体）
- [x] DeleteEntityCommand（删除实体）
- [x] ChangeStyleCommand（修改样式）
- [x] MoveEntityCommand（移动实体）
- [x] ChangePropertyCommand（修改属性）

### 9.3 操作支持

- [x] 绘制管线支持撤销/重做
- [x] 绘制设施支持撤销/重做
- [x] 删除实体支持撤销/重做
- [x] 修改属性支持撤销/重做
- [x] 粘贴样式支持撤销/重做
- [x] 移动实体支持撤销/重做

### 9.4 边界处理

- [ ] 撤销到栈底的处理
- [ ] 重做到栈顶的处理
- [ ] 撤销栈溢出的处理
- [ ] 实体丢失的处理
- [ ] 图形项失效的处理

### 9.5 性能优化

- [x] 移动命令合并（MoveEntityCommand::mergeWith）
- [ ] 属性修改合并（ChangePropertyCommand::mergeWith）
- [ ] 延迟更新待保存列表
- [ ] 批量撤销/重做支持
- [ ] 数据快照机制

---

## 总结

### 10.1 设计要点

1. **双栈机制**：撤销栈和待保存列表协同工作
2. **保存前后一致**：保存后仍可撤销保存前的操作
3. **多次操作支持**：支持任意次数的撤销和重做
4. **交替操作支持**：支持撤销和重做的任意交替
5. **数据一致性**：确保场景、撤销栈和待保存列表的一致性

### 10.2 关键设计决策

1. **保存后不清空撤销栈**：允许撤销保存前的操作
2. **撤销栈限制50步**：平衡功能和性能
3. **待保存列表同步更新**：确保数据一致性
4. **命令模式实现**：使用Qt的QUndoCommand框架

### 10.3 未来改进方向

1. **撤销栈持久化**：保存撤销历史到文件
2. **撤销到标记点**：支持撤销到特定标记位置
3. **撤销历史可视化**：显示撤销历史树
4. **性能进一步优化**：实现数据快照和批量操作

---

**文档版本**：1.0  
**最后更新**：2025-01-27  
**作者**：UGIMS开发团队

